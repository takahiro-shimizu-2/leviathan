
現状分析: 既にLangGraph主導で実装している
証拠
yaml# registry/manifest_langstack.yaml の構造
supreme_orchestrator
  ├─ intent_orchestrator
  ├─ user_clarify
  ├─ yaml_autogen
  ├─ planning_orchestrator
  ├─ execution_orchestrator
  ├─ validation_orchestrator
  ├─ review (HITL)
  ├─ deploy_demo
  └─ observability
これは完全にLangGraphの状態遷移グラフです。CrewAIはexecution_orchestratorノード内で使う想定。

🔍 問題点: 現在は「LangGraphなし」で動いている

最小YAMLパーサの制約により、実行時はアダプタ内のミニマル定義へフォールバックして動作

つまり：

✅ 設計: LangGraph主導の階層的オーケストレーション
❌ 実装: PoC基盤（src/agi_poc/langstack_runner.py）でLangGraph未使用
現状: Pythonコードで直接ノード遷移を記述


💡 推奨: LangGraph実装への段階移行
Phase 1: 現状維持（PoC完成） ✅ 完了
python# src/agi_poc/langstack_runner.py（現行）
def run_orchestration(user_prompt, config):
    state = {"user_input": user_prompt, ...}
    
    # 手動でノード呼び出し
    state = intent_orchestrator(state)
    if state['missing_info']:
        state = user_clarify(state)
    state = yaml_autogen(state)
    state = planning_orchestrator(state)
    state = execution_orchestrator(state)
    state = validation_orchestrator(state)
    
    if state['validation'] == 'changes_requested':
        # カスケード再実行
        state = execution_orchestrator(state, fallback_agent=True)
    
    return state

Phase 2: LangGraph化（次段階）🎯 推奨実装LangGraph統合実装（manifest_langstack.yaml準拠）コード """
"""
LangGraph統合実装
registry/manifest_langstack.yaml の定義をLangGraphワークフローに変換
"""

from typing import TypedDict, Literal, Annotated
import operator
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from crewai import Crew, Agent, Task, Process
from langchain_anthropic import ChatAnthropic
import yaml
from pathlib import Path

# ==========================================
# 状態定義（manifest_langstack.yamlに対応）
# ==========================================
class MVPSystemState(TypedDict):
    """Supreme Orchestrator が管理する全体状態"""
    # 入力
    user_input: str
    attachments: list
    
    # Intent検出結果
    intent_id: str
    intent_spec: dict
    agent_requirements: list
    missing_info: list
    
    # YAML自動生成
    yaml_autogen_status: str
    generated_files: Annotated[list, operator.add]
    
    # Planning
    selected_agents: list
    execution_plan: dict
    strategy: Literal["simple", "ranked", "cascade"]
    
    # Execution
    spec_content: str
    logs: Annotated[list, operator.add]
    retry_count: int
    current_agent_index: int
    
    # Validation
    validation_result: Literal["approved", "changes_requested", "pending"]
    validation_details: dict
    
    # Review (HITL)
    approval_status: Literal["approved", "rejected", "pending"]
    reviewer_comments: str
    
    # Deploy
    demo_url: str
    deploy_status: str
    
    # メタ
    run_id: str
    current_phase: str
    langstack_log: Annotated[list, operator.add]


# ==========================================
# マニフェストローダー
# ==========================================
def load_manifest(path: str = "registry/manifest_langstack.yaml") -> dict:
    """manifest_langstack.yaml を読み込み"""
    with open(path) as f:
        return yaml.safe_load(f)


def load_agent_yaml(agent_path: str) -> dict:
    """agents/*/agent.yml を読み込み"""
    with open(agent_path) as f:
        return yaml.safe_load(f)


def load_intent_yaml(intent_id: str) -> dict:
    """intents/{intent_id}.yml を読み込み（存在する場合）"""
    path = Path(f"intents/{intent_id}.yml")
    if path.exists():
        with open(path) as f:
            return yaml.safe_load(f)
    return None


# ==========================================
# ノード1: Intent Orchestrator
# ==========================================
def intent_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    インテント検出・正規化・軽量検証
    - intents/*.yml から検索または自動生成
    - 出力: intent_spec, agent_requirements, missing_info
    """
    user_input = state["user_input"]
    
    # インテント検出ロジック（現行のdetect_intentを流用）
    from agi_poc.intent_detector import detect_intent
    intent_id = detect_intent(user_input)
    
    # Intent YAML ロード
    intent_spec = load_intent_yaml(intent_id)
    
    if not intent_spec:
        # 自動生成（templates/yaml/basic.yml ベース）
        from agi_poc.yaml_generator import generate_intent_yaml
        intent_spec = generate_intent_yaml(intent_id, user_input)
        
        # 保存
        intent_path = Path(f"intents/{intent_id}.yml")
        with open(intent_path, "w") as f:
            yaml.dump(intent_spec, f)
        
        state["generated_files"].append(str(intent_path))
    
    # 正規化（schemas.pyのnormalize_intent）
    from agi_poc.schemas import normalize_intent
    intent_spec = normalize_intent(intent_spec)
    
    # 不足情報チェック
    missing_info = []
    if not intent_spec.get("inputs"):
        missing_info.append("具体的な入力データ形式")
    if not intent_spec.get("outputs"):
        missing_info.append("期待される出力形式")
    
    # 状態更新
    state["intent_id"] = intent_id
    state["intent_spec"] = intent_spec
    state["agent_requirements"] = intent_spec.get("agent_requirements", [])
    state["missing_info"] = missing_info
    state["current_phase"] = "intent_detected"
    state["langstack_log"].append(f"[IntentOrchestrator] Detected: {intent_id}")
    
    return state


# ==========================================
# ノード2: User Clarify
# ==========================================
def user_clarify_node(state: MVPSystemState) -> MVPSystemState:
    """
    不足情報の質問収集（PoCでは自動クリア）
    将来: 対話インターフェース実装
    """
    missing_info = state["missing_info"]
    
    if missing_info:
        # PoC: 自動的に補完
        state["langstack_log"].append(
            f"[UserClarify] Auto-cleared missing: {missing_info}"
        )
        state["missing_info"] = []  # クリア
    
    state["current_phase"] = "clarified"
    return state


# ==========================================
# ノード3: YAML Autogen
# ==========================================
def yaml_autogen_node(state: MVPSystemState) -> MVPSystemState:
    """
    既存マニフェスト/テンプレから不足YAMLの合成
    - registry/manifest*.yaml, templates/** 参照
    - 出力: registry/generated/*.yaml
    """
    intent_id = state["intent_id"]
    
    # テンプレート選択（現行はbasic.yml固定）
    template_path = "templates/yaml/basic.yml"
    
    # 自動生成（ログ記録のみ）
    state["yaml_autogen_status"] = "completed"
    state["langstack_log"].append(
        f"[YAMLAutogen] Template applied: {template_path}"
    )
    
    state["current_phase"] = "yaml_ready"
    return state


# ==========================================
# ノード4: Planning Orchestrator
# ==========================================
def planning_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    エージェント選定/生成、実行計画
    - agents/*/agent.yml から capabilities 一致を検索
    - strategy (simple/ranked/cascade) に応じて計画
    """
    intent_spec = state["intent_spec"]
    agent_requirements = state["agent_requirements"]
    strategy = state.get("strategy", "ranked")
    
    # エージェント候補収集
    from agi_poc.agent_selector import select_agents
    candidates = select_agents(
        capabilities=agent_requirements,
        intent_id=state["intent_id"]
    )
    
    # 戦略別の計画
    if strategy == "simple":
        selected_agents = [candidates[0]] if candidates else []
    elif strategy == "ranked":
        selected_agents = candidates[:3]  # 上位3つ
    elif strategy == "cascade":
        selected_agents = candidates  # 全候補（失敗時順次実行）
    
    # エージェント未存在時の自動生成
    if not selected_agents:
        from agi_poc.agent_builder import build_agent_from_template
        auto_agent = build_agent_from_template(
            intent_id=state["intent_id"],
            requirements=agent_requirements
        )
        selected_agents = [auto_agent]
        
        # 保存
        agent_path = Path(f"agents/auto_{state['intent_id']}/agent.yml")
        agent_path.parent.mkdir(parents=True, exist_ok=True)
        with open(agent_path, "w") as f:
            yaml.dump(auto_agent, f)
        
        state["generated_files"].append(str(agent_path))
    
    # 実行計画
    execution_plan = {
        "agents": selected_agents,
        "timeout_s": intent_spec.get("timeout_s", 60),
        "max_retries": 3 if strategy == "cascade" else 1
    }
    
    state["selected_agents"] = selected_agents
    state["execution_plan"] = execution_plan
    state["current_phase"] = "planned"
    state["langstack_log"].append(
        f"[PlanningOrchestrator] Selected {len(selected_agents)} agents"
    )
    
    return state


# ==========================================
# ノード5: Execution Orchestrator (CrewAI統合)
# ==========================================
def execution_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    エージェント実行（CrewAI使用）
    - 並列実行想定（PoCは bin/agent_cli で順次）
    - 失敗時はカスケード再実行
    """
    selected_agents = state["selected_agents"]
    current_index = state.get("current_agent_index", 0)
    execution_plan = state["execution_plan"]
    
    if current_index >= len(selected_agents):
        # 全エージェント失敗
        state["validation_result"] = "changes_requested"
        state["langstack_log"].append(
            "[ExecutionOrchestrator] All agents failed"
        )
        return state
    
    # 現在のエージェント
    agent_config = selected_agents[current_index]
    
    # CrewAI エージェント生成
    crew_agent = Agent(
        role=agent_config.get("role", "Spec Writer"),
        goal=agent_config.get("goal", "Generate SPEC.md"),
        backstory=agent_config.get("backstory", "Expert technical writer"),
        llm=ChatAnthropic(
            model=agent_config.get("model", "claude-sonnet-4.5"),
            temperature=agent_config.get("temperature", 0.7)
        ),
        verbose=True
    )
    
    # タスク定義
    task = Task(
        description=f"Create SPEC.md for: {state['user_input']}",
        agent=crew_agent,
        expected_output="Complete SPEC.md with all required sections"
    )
    
    # Crew実行
    crew = Crew(
        agents=[crew_agent],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )
    
    try:
        result = crew.kickoff()
        
        # SPEC.md 保存
        run_id = state["run_id"]
        spec_path = Path(f"runs/{run_id}/SPEC.md")
        spec_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(spec_path, "w") as f:
            f.write(str(result))
        
        state["spec_content"] = str(result)
        state["current_phase"] = "executed"
        state["langstack_log"].append(
            f"[ExecutionOrchestrator] Agent {current_index} succeeded"
        )
        
    except Exception as e:
        # 失敗時の処理
        state["logs"].append(f"Agent {current_index} failed: {str(e)}")
        state["current_agent_index"] = current_index + 1
        state["retry_count"] += 1
        
        state["langstack_log"].append(
            f"[ExecutionOrchestrator] Agent {current_index} failed, "
            f"trying next (retry={state['retry_count']})"
        )
        
        # カスケード: 次のエージェントへ
        if state["execution_plan"]["max_retries"] > state["retry_count"]:
            return execution_orchestrator_node(state)  # 再帰呼び出し
    
    return state


# ==========================================
# ノード6: Validation Orchestrator
# ==========================================
def validation_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    自動検証（evaluate_success + ポリシー）
    - SPEC.md の必須セクション/API表/ユースケース等をチェック
    - NG なら changes_requested で差戻し
    """
    spec_content = state.get("spec_content", "")
    
    if not spec_content:
        state["validation_result"] = "changes_requested"
        state["validation_details"] = {"error": "No SPEC.md generated"}
        return state
    
    # 検証ロジック（現行のevaluate_successを流用）
    from agi_poc.validator import evaluate_success
    validation = evaluate_success(spec_content)
    
    if validation["success"]:
        state["validation_result"] = "approved"
        state["langstack_log"].append(
            "[ValidationOrchestrator] APPROVED: All checks passed"
        )
    else:
        state["validation_result"] = "changes_requested"
        state["langstack_log"].append(
            f"[ValidationOrchestrator] CHANGES_REQUESTED: {validation['reason']}"
        )
    
    state["validation_details"] = validation
    state["current_phase"] = "validated"
    
    return state


# ==========================================
# ノード7: Review (HITL)
# ==========================================
def review_node(state: MVPSystemState) -> MVPSystemState:
    """
    ヒト承認（PoCは自動承認）
    将来: Slack/Email通知 + 承認UI
    """
    # PoC: 自動承認
    state["approval_status"] = "approved"
    state["reviewer_comments"] = "Auto-approved in PoC mode"
    state["current_phase"] = "reviewed"
    
    state["langstack_log"].append(
        "[Review] Auto-approved (PoC mode)"
    )
    
    return state


# ==========================================
# ノード8: Deploy Demo
# ==========================================
def deploy_demo_node(state: MVPSystemState) -> MVPSystemState:
    """
    デモ展開（PoCはログ記録）
    将来: Vercel/Docker Compose デプロイ
    """
    # PoC: ログ記録のみ
    state["deploy_status"] = "simulated"
    state["demo_url"] = f"http://localhost:3000/{state['run_id']}"
    state["current_phase"] = "deployed"
    
    state["langstack_log"].append(
        f"[DeployDemo] Simulated deployment: {state['demo_url']}"
    )
    
    return state


# ==========================================
# ルーティング関数（条件分岐）
# ==========================================
def route_after_intent(
    state: MVPSystemState
) -> Literal["clarify", "yaml_autogen"]:
    """Intent検出後のルーティング"""
    if state["missing_info"]:
        return "clarify"
    return "yaml_autogen"


def route_after_validation(
    state: MVPSystemState
) -> Literal["review", "execution"]:
    """Validation後のルーティング"""
    if state["validation_result"] == "approved":
        return "review"
    else:
        # 差戻し: 再実行
        return "execution"


def route_after_review(
    state: MVPSystemState
) -> Literal["deploy", "execution", "end"]:
    """Review後のルーティング"""
    if state["approval_status"] == "approved":
        return "deploy"
    elif state["approval_status"] == "rejected":
        return "end"
    else:
        # 要修正
        return "execution"


# ==========================================
# LangGraph ワークフロー構築
# ==========================================
def build_mvp_workflow() -> StateGraph:
    """
    manifest_langstack.yaml に基づくLangGraphワークフロー
    """
    workflow = StateGraph(MVPSystemState)
    
    # ノード追加
    workflow.add_node("intent", intent_orchestrator_node)
    workflow.add_node("clarify", user_clarify_node)
    workflow.add_node("yaml_autogen", yaml_autogen_node)
    workflow.add_node("planning", planning_orchestrator_node)
    workflow.add_node("execution", execution_orchestrator_node)
    workflow.add_node("validation", validation_orchestrator_node)
    workflow.add_node("review", review_node)
    workflow.add_node("deploy", deploy_demo_node)
    
    # エントリーポイント
    workflow.set_entry_point("intent")
    
    # エッジ定義
    workflow.add_conditional_edges(
        "intent",
        route_after_intent,
        {
            "clarify": "clarify",
            "yaml_autogen": "yaml_autogen"
        }
    )
    
    workflow.add_edge("clarify", "yaml_autogen")
    workflow.add_edge("yaml_autogen", "planning")
    workflow.add_edge("planning", "execution")
    workflow.add_edge("execution", "validation")
    
    workflow.add_conditional_edges(
        "validation",
        route_after_validation,
        {
            "review": "review",
            "execution": "execution"  # 差戻しループ
        }
    )
    
    workflow.add_conditional_edges(
        "review",
        route_after_review,
        {
            "deploy": "deploy",
            "execution": "execution",
            "end": END
        }
    )
    
    workflow.add_edge("deploy", END)
    
    return workflow


# ==========================================
# 実行関数
# ==========================================
def run_mvp_generation(
    user_prompt: str,
    run_id: str,
    strategy: str = "ranked",
    simulate: bool = False
) -> dict:
    """
    MVPシステムの実行エントリーポイント
    
    Args:
        user_prompt: ユーザー要件（自然文）
        run_id: 実行ID
        strategy: エージェント選定戦略（simple/ranked/cascade）
        simulate: シミュレーションモード
    
    Returns:
        最終状態（SPEC.md生成結果等）
    """
    # Checkpointer設定（SQLite永続化）
    checkpointer = SqliteSaver.from_conn_string(f"runs/{run_id}/checkpoint.db")
    
    # ワークフロー構築
    workflow = build_mvp_workflow()
    app = workflow.compile(checkpointer=checkpointer)
    
    # 初期状態
    initial_state = {
        "user_input": user_prompt,
        "attachments": [],
        "intent_id": "",
        "intent_spec": {},
        "agent_requirements": [],
        "missing_info": [],
        "yaml_autogen_status": "",
        "generated_files": [],
        "selected_agents": [],
        "execution_plan": {},
        "strategy": strategy,
        "spec_content": "",
        "logs": [],
        "retry_count": 0,
        "current_agent_index": 0,
        "validation_result": "pending",
        "validation_details": {},
        "approval_status": "pending",
        "reviewer_comments": "",
        "demo_url": "",
        "deploy_status": "",
        "run_id": run_id,
        "current_phase": "initial",
        "langstack_log": []
    }
    
    # 実行設定
    config = {
        "configurable": {
            "thread_id": run_id,
            "simulate": simulate
        }
    }
    
    # 実行
    if simulate:
        print(f"[SIMULATE] Running workflow for: {user_prompt}")
    
    final_state = app.invoke(initial_state, config)
    
    # langstack.txt 出力
    langstack_path = Path(f"runs/{run_id}/langstack.txt")
    langstack_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(langstack_path, "w") as f:
        f.write("=== LangGraph Execution Log ===\n")
        for log in final_state["langstack_log"]:
            f.write(f"{log}\n")
        f.write(f"\nFinal Phase: {final_state['current_phase']}\n")
        f.write(f"Validation: {final_state['validation_result']}\n")
    
    return final_state


# ==========================================
# CLI統合（既存 bin/langstack との互換性）
# ==========================================
if __name__ == "__main__":
    import sys
    from datetime import datetime
    
    if len(sys.argv) < 2:
        print("Usage: python langgraph_runner.py '<user_prompt>' [--simulate]")
        sys.exit(1)
    
    user_prompt = sys.argv[1]
    simulate = "--simulate" in sys.argv
    
    run_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    result = run_mvp_generation(
        user_prompt=user_prompt,
        run_id=run_id,
        strategy="ranked",
        simulate=simulate
    )
    
    print("\n=== Execution Complete ===")
    print(f"Run ID: {run_id}")
    print(f"Phase: {result['current_phase']}")
    print(f"Validation: {result['validation_result']}")
    print(f"SPEC: runs/{run_id}/SPEC.md")
    print(f"Log: runs/{run_id}/langstack.txt")


LangGraph統合実装
registry/manifest_langstack.yaml の定義をLangGraphワークフローに変換
"""

from typing import TypedDict, Literal, Annotated
import operator
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from crewa📊 実装比較: 現行 vs LangGraph化
要素現行PoCLangGraph統合状態管理辞書を手動で引き回しStateGraph が自動管理分岐制御if-else で手動実装add_conditional_edges で宣言的永続化ファイルI/OのみSqliteSaver で自動チェックポイント再実行全体を最初から特定ノードから再開可能カスケード手動ループグラフのエッジで自然に表現ログ手動で langstack.txt 書き込みstate["langstack_log"] に追記CrewAI統合bin/agent_cli 経由execution_orchestrator_node 内で直接呼び出し

🎯 最終回答: あなたのケースでの最適構成
✅ LangGraph主導 + CrewAIノード統合を推奨
理由（ドキュメントベース）:

既に設計がLangGraphそのもの

yaml   # manifest_langstack.yaml
   nodes:
     - supreme_orchestrator
     - intent_orchestrator
     - execution_orchestrator
     - validation_orchestrator
これは完全にLangGraphのStateGraph構造。

複雑な条件分岐が必須

Intent検出後: missing_info → clarify or yaml_autogen
Validation後: approved → review or changes_requested → execution（差戻し）
Review後: approved → deploy or rejected → END


長時間実行と中断・再開

timeout_s: 60 （Intent YAML）
MVP生成は数分〜数十分
Checkpointingで途中保存が必須


カスケード再実行

失敗時に selected_agents[1], [2], ... と順次実行
LangGraphなら execution → validation → execution のループで自然に実装


CrewAIは execution_orchestrator 内でカプセル化

エージェント実行部分だけCrewAIの Crew.kickoff()
全体の制御フローはLangGraph




🏗️ 段階的移行プラン
Phase 2.1: LangGraph最小導入
python# src/agi_poc/langgraph_runner.py（新規）
from langgraph.graph import StateGraph

workflow = StateGraph(MVPSystemState)
workflow.add_node("intent", intent_orchestrator_node)
workflow.add_node("execution", execution_orchestrator_node)
workflow.add_edge("intent", "execution")

app = workflow.compile()
既存の langstack_runner.py はそのまま残し、--experimental-langgraph フラグで切り替え。
Phase 2.2: Checkpointing導入（1週間）
pythonfrom langgraph.checkpoint.sqlite import SqliteSaver

checkpointer = SqliteSaver.from_conn_string(
    f"runs/{run_id}/checkpoint.db"
)
app = workflow.compile(checkpointer=checkpointer)

# 中断後の再開
app.invoke(None, config={"configurable": {"thread_id": run_id}})
Phase 2.3: CrewAI統合
pythondef execution_orchestrator_node(state):
    # 既存の bin/agent_cli 呼び出しを置き換え
    crew = Crew(agents=[...], tasks=[...])
    result = crew.kickoff(inputs=state)
    return state
Phase 2.4: 条件分岐完全化
pythonworkflow.add_conditional_edges(
    "validation",
    route_after_validation,
    {"review": "review", "execution": "execution"}
)

🚀 即座に使えるコマンド（移行後）
bash# LangGraph版実行
python src/agi_poc/langgraph_runner.py "タスク管理アプリのSPEC作成" --simulate

# 実運用
python src/agi_poc/langgraph_runner.py "ECサイトの仕様書" --yes

# 既存CLI（互換性維持）
python bin/langstack run --input "要件" --experimental-langgraph

📋 チェックリスト
LangGraph導入前に確認:

 langgraph, langgraph-checkpoint-sqlite をインストール
 MVPSystemState の型定義を src/agi_poc/schemas.py に追加
 既存の langstack_runner.py をバックアップ
 テストケース準備（tests/test_langgraph_integration.py）


💡 結論
あなたは既にLangGraph主導のアーキテクチャを設計済みです。現在はPoCで手動実装していますが、次段階でLangGraph実装に移行すべきです。
CrewAIは execution_orchestrator ノード内で使い、全体制御はLangGraphに任せるのが最適です。