
ç¾çŠ¶åˆ†æ: æ—¢ã«LangGraphä¸»å°ã§å®Ÿè£…ã—ã¦ã„ã‚‹
è¨¼æ‹ 
yaml# registry/manifest_langstack.yaml ã®æ§‹é€ 
supreme_orchestrator
  â”œâ”€ intent_orchestrator
  â”œâ”€ user_clarify
  â”œâ”€ yaml_autogen
  â”œâ”€ planning_orchestrator
  â”œâ”€ execution_orchestrator
  â”œâ”€ validation_orchestrator
  â”œâ”€ review (HITL)
  â”œâ”€ deploy_demo
  â””â”€ observability
ã“ã‚Œã¯å®Œå…¨ã«LangGraphã®çŠ¶æ…‹é·ç§»ã‚°ãƒ©ãƒ•ã§ã™ã€‚CrewAIã¯execution_orchestratorãƒãƒ¼ãƒ‰å†…ã§ä½¿ã†æƒ³å®šã€‚

ğŸ” å•é¡Œç‚¹: ç¾åœ¨ã¯ã€ŒLangGraphãªã—ã€ã§å‹•ã„ã¦ã„ã‚‹

æœ€å°YAMLãƒ‘ãƒ¼ã‚µã®åˆ¶ç´„ã«ã‚ˆã‚Šã€å®Ÿè¡Œæ™‚ã¯ã‚¢ãƒ€ãƒ—ã‚¿å†…ã®ãƒŸãƒ‹ãƒãƒ«å®šç¾©ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ã¦å‹•ä½œ

ã¤ã¾ã‚Šï¼š

âœ… è¨­è¨ˆ: LangGraphä¸»å°ã®éšå±¤çš„ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
âŒ å®Ÿè£…: PoCåŸºç›¤ï¼ˆsrc/agi_poc/langstack_runner.pyï¼‰ã§LangGraphæœªä½¿ç”¨
ç¾çŠ¶: Pythonã‚³ãƒ¼ãƒ‰ã§ç›´æ¥ãƒãƒ¼ãƒ‰é·ç§»ã‚’è¨˜è¿°


ğŸ’¡ æ¨å¥¨: LangGraphå®Ÿè£…ã¸ã®æ®µéšç§»è¡Œ
Phase 1: ç¾çŠ¶ç¶­æŒï¼ˆPoCå®Œæˆï¼‰ âœ… å®Œäº†
python# src/agi_poc/langstack_runner.pyï¼ˆç¾è¡Œï¼‰
def run_orchestration(user_prompt, config):
    state = {"user_input": user_prompt, ...}
    
    # æ‰‹å‹•ã§ãƒãƒ¼ãƒ‰å‘¼ã³å‡ºã—
    state = intent_orchestrator(state)
    if state['missing_info']:
        state = user_clarify(state)
    state = yaml_autogen(state)
    state = planning_orchestrator(state)
    state = execution_orchestrator(state)
    state = validation_orchestrator(state)
    
    if state['validation'] == 'changes_requested':
        # ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å†å®Ÿè¡Œ
        state = execution_orchestrator(state, fallback_agent=True)
    
    return state

Phase 2: LangGraphåŒ–ï¼ˆæ¬¡æ®µéšï¼‰ğŸ¯ æ¨å¥¨å®Ÿè£…LangGraphçµ±åˆå®Ÿè£…ï¼ˆmanifest_langstack.yamlæº–æ‹ ï¼‰ã‚³ãƒ¼ãƒ‰Â """
"""
LangGraphçµ±åˆå®Ÿè£…
registry/manifest_langstack.yaml ã®å®šç¾©ã‚’LangGraphãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«å¤‰æ›
"""

from typing import TypedDict, Literal, Annotated
import operator
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from crewai import Crew, Agent, Task, Process
from langchain_anthropic import ChatAnthropic
import yaml
from pathlib import Path

# ==========================================
# çŠ¶æ…‹å®šç¾©ï¼ˆmanifest_langstack.yamlã«å¯¾å¿œï¼‰
# ==========================================
class MVPSystemState(TypedDict):
    """Supreme Orchestrator ãŒç®¡ç†ã™ã‚‹å…¨ä½“çŠ¶æ…‹"""
    # å…¥åŠ›
    user_input: str
    attachments: list
    
    # Intentæ¤œå‡ºçµæœ
    intent_id: str
    intent_spec: dict
    agent_requirements: list
    missing_info: list
    
    # YAMLè‡ªå‹•ç”Ÿæˆ
    yaml_autogen_status: str
    generated_files: Annotated[list, operator.add]
    
    # Planning
    selected_agents: list
    execution_plan: dict
    strategy: Literal["simple", "ranked", "cascade"]
    
    # Execution
    spec_content: str
    logs: Annotated[list, operator.add]
    retry_count: int
    current_agent_index: int
    
    # Validation
    validation_result: Literal["approved", "changes_requested", "pending"]
    validation_details: dict
    
    # Review (HITL)
    approval_status: Literal["approved", "rejected", "pending"]
    reviewer_comments: str
    
    # Deploy
    demo_url: str
    deploy_status: str
    
    # ãƒ¡ã‚¿
    run_id: str
    current_phase: str
    langstack_log: Annotated[list, operator.add]


# ==========================================
# ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆãƒ­ãƒ¼ãƒ€ãƒ¼
# ==========================================
def load_manifest(path: str = "registry/manifest_langstack.yaml") -> dict:
    """manifest_langstack.yaml ã‚’èª­ã¿è¾¼ã¿"""
    with open(path) as f:
        return yaml.safe_load(f)


def load_agent_yaml(agent_path: str) -> dict:
    """agents/*/agent.yml ã‚’èª­ã¿è¾¼ã¿"""
    with open(agent_path) as f:
        return yaml.safe_load(f)


def load_intent_yaml(intent_id: str) -> dict:
    """intents/{intent_id}.yml ã‚’èª­ã¿è¾¼ã¿ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰"""
    path = Path(f"intents/{intent_id}.yml")
    if path.exists():
        with open(path) as f:
            return yaml.safe_load(f)
    return None


# ==========================================
# ãƒãƒ¼ãƒ‰1: Intent Orchestrator
# ==========================================
def intent_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    ã‚¤ãƒ³ãƒ†ãƒ³ãƒˆæ¤œå‡ºãƒ»æ­£è¦åŒ–ãƒ»è»½é‡æ¤œè¨¼
    - intents/*.yml ã‹ã‚‰æ¤œç´¢ã¾ãŸã¯è‡ªå‹•ç”Ÿæˆ
    - å‡ºåŠ›: intent_spec, agent_requirements, missing_info
    """
    user_input = state["user_input"]
    
    # ã‚¤ãƒ³ãƒ†ãƒ³ãƒˆæ¤œå‡ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆç¾è¡Œã®detect_intentã‚’æµç”¨ï¼‰
    from agi_poc.intent_detector import detect_intent
    intent_id = detect_intent(user_input)
    
    # Intent YAML ãƒ­ãƒ¼ãƒ‰
    intent_spec = load_intent_yaml(intent_id)
    
    if not intent_spec:
        # è‡ªå‹•ç”Ÿæˆï¼ˆtemplates/yaml/basic.yml ãƒ™ãƒ¼ã‚¹ï¼‰
        from agi_poc.yaml_generator import generate_intent_yaml
        intent_spec = generate_intent_yaml(intent_id, user_input)
        
        # ä¿å­˜
        intent_path = Path(f"intents/{intent_id}.yml")
        with open(intent_path, "w") as f:
            yaml.dump(intent_spec, f)
        
        state["generated_files"].append(str(intent_path))
    
    # æ­£è¦åŒ–ï¼ˆschemas.pyã®normalize_intentï¼‰
    from agi_poc.schemas import normalize_intent
    intent_spec = normalize_intent(intent_spec)
    
    # ä¸è¶³æƒ…å ±ãƒã‚§ãƒƒã‚¯
    missing_info = []
    if not intent_spec.get("inputs"):
        missing_info.append("å…·ä½“çš„ãªå…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼")
    if not intent_spec.get("outputs"):
        missing_info.append("æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›å½¢å¼")
    
    # çŠ¶æ…‹æ›´æ–°
    state["intent_id"] = intent_id
    state["intent_spec"] = intent_spec
    state["agent_requirements"] = intent_spec.get("agent_requirements", [])
    state["missing_info"] = missing_info
    state["current_phase"] = "intent_detected"
    state["langstack_log"].append(f"[IntentOrchestrator] Detected: {intent_id}")
    
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰2: User Clarify
# ==========================================
def user_clarify_node(state: MVPSystemState) -> MVPSystemState:
    """
    ä¸è¶³æƒ…å ±ã®è³ªå•åé›†ï¼ˆPoCã§ã¯è‡ªå‹•ã‚¯ãƒªã‚¢ï¼‰
    å°†æ¥: å¯¾è©±ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…
    """
    missing_info = state["missing_info"]
    
    if missing_info:
        # PoC: è‡ªå‹•çš„ã«è£œå®Œ
        state["langstack_log"].append(
            f"[UserClarify] Auto-cleared missing: {missing_info}"
        )
        state["missing_info"] = []  # ã‚¯ãƒªã‚¢
    
    state["current_phase"] = "clarified"
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰3: YAML Autogen
# ==========================================
def yaml_autogen_node(state: MVPSystemState) -> MVPSystemState:
    """
    æ—¢å­˜ãƒãƒ‹ãƒ•ã‚§ã‚¹ãƒˆ/ãƒ†ãƒ³ãƒ—ãƒ¬ã‹ã‚‰ä¸è¶³YAMLã®åˆæˆ
    - registry/manifest*.yaml, templates/** å‚ç…§
    - å‡ºåŠ›: registry/generated/*.yaml
    """
    intent_id = state["intent_id"]
    
    # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé¸æŠï¼ˆç¾è¡Œã¯basic.ymlå›ºå®šï¼‰
    template_path = "templates/yaml/basic.yml"
    
    # è‡ªå‹•ç”Ÿæˆï¼ˆãƒ­ã‚°è¨˜éŒ²ã®ã¿ï¼‰
    state["yaml_autogen_status"] = "completed"
    state["langstack_log"].append(
        f"[YAMLAutogen] Template applied: {template_path}"
    )
    
    state["current_phase"] = "yaml_ready"
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰4: Planning Orchestrator
# ==========================================
def planning_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé¸å®š/ç”Ÿæˆã€å®Ÿè¡Œè¨ˆç”»
    - agents/*/agent.yml ã‹ã‚‰ capabilities ä¸€è‡´ã‚’æ¤œç´¢
    - strategy (simple/ranked/cascade) ã«å¿œã˜ã¦è¨ˆç”»
    """
    intent_spec = state["intent_spec"]
    agent_requirements = state["agent_requirements"]
    strategy = state.get("strategy", "ranked")
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå€™è£œåé›†
    from agi_poc.agent_selector import select_agents
    candidates = select_agents(
        capabilities=agent_requirements,
        intent_id=state["intent_id"]
    )
    
    # æˆ¦ç•¥åˆ¥ã®è¨ˆç”»
    if strategy == "simple":
        selected_agents = [candidates[0]] if candidates else []
    elif strategy == "ranked":
        selected_agents = candidates[:3]  # ä¸Šä½3ã¤
    elif strategy == "cascade":
        selected_agents = candidates  # å…¨å€™è£œï¼ˆå¤±æ•—æ™‚é †æ¬¡å®Ÿè¡Œï¼‰
    
    # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæœªå­˜åœ¨æ™‚ã®è‡ªå‹•ç”Ÿæˆ
    if not selected_agents:
        from agi_poc.agent_builder import build_agent_from_template
        auto_agent = build_agent_from_template(
            intent_id=state["intent_id"],
            requirements=agent_requirements
        )
        selected_agents = [auto_agent]
        
        # ä¿å­˜
        agent_path = Path(f"agents/auto_{state['intent_id']}/agent.yml")
        agent_path.parent.mkdir(parents=True, exist_ok=True)
        with open(agent_path, "w") as f:
            yaml.dump(auto_agent, f)
        
        state["generated_files"].append(str(agent_path))
    
    # å®Ÿè¡Œè¨ˆç”»
    execution_plan = {
        "agents": selected_agents,
        "timeout_s": intent_spec.get("timeout_s", 60),
        "max_retries": 3 if strategy == "cascade" else 1
    }
    
    state["selected_agents"] = selected_agents
    state["execution_plan"] = execution_plan
    state["current_phase"] = "planned"
    state["langstack_log"].append(
        f"[PlanningOrchestrator] Selected {len(selected_agents)} agents"
    )
    
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰5: Execution Orchestrator (CrewAIçµ±åˆ)
# ==========================================
def execution_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œï¼ˆCrewAIä½¿ç”¨ï¼‰
    - ä¸¦åˆ—å®Ÿè¡Œæƒ³å®šï¼ˆPoCã¯ bin/agent_cli ã§é †æ¬¡ï¼‰
    - å¤±æ•—æ™‚ã¯ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å†å®Ÿè¡Œ
    """
    selected_agents = state["selected_agents"]
    current_index = state.get("current_agent_index", 0)
    execution_plan = state["execution_plan"]
    
    if current_index >= len(selected_agents):
        # å…¨ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå¤±æ•—
        state["validation_result"] = "changes_requested"
        state["langstack_log"].append(
            "[ExecutionOrchestrator] All agents failed"
        )
        return state
    
    # ç¾åœ¨ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    agent_config = selected_agents[current_index]
    
    # CrewAI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç”Ÿæˆ
    crew_agent = Agent(
        role=agent_config.get("role", "Spec Writer"),
        goal=agent_config.get("goal", "Generate SPEC.md"),
        backstory=agent_config.get("backstory", "Expert technical writer"),
        llm=ChatAnthropic(
            model=agent_config.get("model", "claude-sonnet-4.5"),
            temperature=agent_config.get("temperature", 0.7)
        ),
        verbose=True
    )
    
    # ã‚¿ã‚¹ã‚¯å®šç¾©
    task = Task(
        description=f"Create SPEC.md for: {state['user_input']}",
        agent=crew_agent,
        expected_output="Complete SPEC.md with all required sections"
    )
    
    # Crewå®Ÿè¡Œ
    crew = Crew(
        agents=[crew_agent],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )
    
    try:
        result = crew.kickoff()
        
        # SPEC.md ä¿å­˜
        run_id = state["run_id"]
        spec_path = Path(f"runs/{run_id}/SPEC.md")
        spec_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(spec_path, "w") as f:
            f.write(str(result))
        
        state["spec_content"] = str(result)
        state["current_phase"] = "executed"
        state["langstack_log"].append(
            f"[ExecutionOrchestrator] Agent {current_index} succeeded"
        )
        
    except Exception as e:
        # å¤±æ•—æ™‚ã®å‡¦ç†
        state["logs"].append(f"Agent {current_index} failed: {str(e)}")
        state["current_agent_index"] = current_index + 1
        state["retry_count"] += 1
        
        state["langstack_log"].append(
            f"[ExecutionOrchestrator] Agent {current_index} failed, "
            f"trying next (retry={state['retry_count']})"
        )
        
        # ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰: æ¬¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸
        if state["execution_plan"]["max_retries"] > state["retry_count"]:
            return execution_orchestrator_node(state)  # å†å¸°å‘¼ã³å‡ºã—
    
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰6: Validation Orchestrator
# ==========================================
def validation_orchestrator_node(state: MVPSystemState) -> MVPSystemState:
    """
    è‡ªå‹•æ¤œè¨¼ï¼ˆevaluate_success + ãƒãƒªã‚·ãƒ¼ï¼‰
    - SPEC.md ã®å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³/APIè¡¨/ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ç­‰ã‚’ãƒã‚§ãƒƒã‚¯
    - NG ãªã‚‰ changes_requested ã§å·®æˆ»ã—
    """
    spec_content = state.get("spec_content", "")
    
    if not spec_content:
        state["validation_result"] = "changes_requested"
        state["validation_details"] = {"error": "No SPEC.md generated"}
        return state
    
    # æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆç¾è¡Œã®evaluate_successã‚’æµç”¨ï¼‰
    from agi_poc.validator import evaluate_success
    validation = evaluate_success(spec_content)
    
    if validation["success"]:
        state["validation_result"] = "approved"
        state["langstack_log"].append(
            "[ValidationOrchestrator] APPROVED: All checks passed"
        )
    else:
        state["validation_result"] = "changes_requested"
        state["langstack_log"].append(
            f"[ValidationOrchestrator] CHANGES_REQUESTED: {validation['reason']}"
        )
    
    state["validation_details"] = validation
    state["current_phase"] = "validated"
    
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰7: Review (HITL)
# ==========================================
def review_node(state: MVPSystemState) -> MVPSystemState:
    """
    ãƒ’ãƒˆæ‰¿èªï¼ˆPoCã¯è‡ªå‹•æ‰¿èªï¼‰
    å°†æ¥: Slack/Emailé€šçŸ¥ + æ‰¿èªUI
    """
    # PoC: è‡ªå‹•æ‰¿èª
    state["approval_status"] = "approved"
    state["reviewer_comments"] = "Auto-approved in PoC mode"
    state["current_phase"] = "reviewed"
    
    state["langstack_log"].append(
        "[Review] Auto-approved (PoC mode)"
    )
    
    return state


# ==========================================
# ãƒãƒ¼ãƒ‰8: Deploy Demo
# ==========================================
def deploy_demo_node(state: MVPSystemState) -> MVPSystemState:
    """
    ãƒ‡ãƒ¢å±•é–‹ï¼ˆPoCã¯ãƒ­ã‚°è¨˜éŒ²ï¼‰
    å°†æ¥: Vercel/Docker Compose ãƒ‡ãƒ—ãƒ­ã‚¤
    """
    # PoC: ãƒ­ã‚°è¨˜éŒ²ã®ã¿
    state["deploy_status"] = "simulated"
    state["demo_url"] = f"http://localhost:3000/{state['run_id']}"
    state["current_phase"] = "deployed"
    
    state["langstack_log"].append(
        f"[DeployDemo] Simulated deployment: {state['demo_url']}"
    )
    
    return state


# ==========================================
# ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°é–¢æ•°ï¼ˆæ¡ä»¶åˆ†å²ï¼‰
# ==========================================
def route_after_intent(
    state: MVPSystemState
) -> Literal["clarify", "yaml_autogen"]:
    """Intentæ¤œå‡ºå¾Œã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
    if state["missing_info"]:
        return "clarify"
    return "yaml_autogen"


def route_after_validation(
    state: MVPSystemState
) -> Literal["review", "execution"]:
    """Validationå¾Œã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
    if state["validation_result"] == "approved":
        return "review"
    else:
        # å·®æˆ»ã—: å†å®Ÿè¡Œ
        return "execution"


def route_after_review(
    state: MVPSystemState
) -> Literal["deploy", "execution", "end"]:
    """Reviewå¾Œã®ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°"""
    if state["approval_status"] == "approved":
        return "deploy"
    elif state["approval_status"] == "rejected":
        return "end"
    else:
        # è¦ä¿®æ­£
        return "execution"


# ==========================================
# LangGraph ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ§‹ç¯‰
# ==========================================
def build_mvp_workflow() -> StateGraph:
    """
    manifest_langstack.yaml ã«åŸºã¥ãLangGraphãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
    """
    workflow = StateGraph(MVPSystemState)
    
    # ãƒãƒ¼ãƒ‰è¿½åŠ 
    workflow.add_node("intent", intent_orchestrator_node)
    workflow.add_node("clarify", user_clarify_node)
    workflow.add_node("yaml_autogen", yaml_autogen_node)
    workflow.add_node("planning", planning_orchestrator_node)
    workflow.add_node("execution", execution_orchestrator_node)
    workflow.add_node("validation", validation_orchestrator_node)
    workflow.add_node("review", review_node)
    workflow.add_node("deploy", deploy_demo_node)
    
    # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
    workflow.set_entry_point("intent")
    
    # ã‚¨ãƒƒã‚¸å®šç¾©
    workflow.add_conditional_edges(
        "intent",
        route_after_intent,
        {
            "clarify": "clarify",
            "yaml_autogen": "yaml_autogen"
        }
    )
    
    workflow.add_edge("clarify", "yaml_autogen")
    workflow.add_edge("yaml_autogen", "planning")
    workflow.add_edge("planning", "execution")
    workflow.add_edge("execution", "validation")
    
    workflow.add_conditional_edges(
        "validation",
        route_after_validation,
        {
            "review": "review",
            "execution": "execution"  # å·®æˆ»ã—ãƒ«ãƒ¼ãƒ—
        }
    )
    
    workflow.add_conditional_edges(
        "review",
        route_after_review,
        {
            "deploy": "deploy",
            "execution": "execution",
            "end": END
        }
    )
    
    workflow.add_edge("deploy", END)
    
    return workflow


# ==========================================
# å®Ÿè¡Œé–¢æ•°
# ==========================================
def run_mvp_generation(
    user_prompt: str,
    run_id: str,
    strategy: str = "ranked",
    simulate: bool = False
) -> dict:
    """
    MVPã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè¡Œã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
    
    Args:
        user_prompt: ãƒ¦ãƒ¼ã‚¶ãƒ¼è¦ä»¶ï¼ˆè‡ªç„¶æ–‡ï¼‰
        run_id: å®Ÿè¡ŒID
        strategy: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé¸å®šæˆ¦ç•¥ï¼ˆsimple/ranked/cascadeï¼‰
        simulate: ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ¼ãƒ‰
    
    Returns:
        æœ€çµ‚çŠ¶æ…‹ï¼ˆSPEC.mdç”Ÿæˆçµæœç­‰ï¼‰
    """
    # Checkpointerè¨­å®šï¼ˆSQLiteæ°¸ç¶šåŒ–ï¼‰
    checkpointer = SqliteSaver.from_conn_string(f"runs/{run_id}/checkpoint.db")
    
    # ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ§‹ç¯‰
    workflow = build_mvp_workflow()
    app = workflow.compile(checkpointer=checkpointer)
    
    # åˆæœŸçŠ¶æ…‹
    initial_state = {
        "user_input": user_prompt,
        "attachments": [],
        "intent_id": "",
        "intent_spec": {},
        "agent_requirements": [],
        "missing_info": [],
        "yaml_autogen_status": "",
        "generated_files": [],
        "selected_agents": [],
        "execution_plan": {},
        "strategy": strategy,
        "spec_content": "",
        "logs": [],
        "retry_count": 0,
        "current_agent_index": 0,
        "validation_result": "pending",
        "validation_details": {},
        "approval_status": "pending",
        "reviewer_comments": "",
        "demo_url": "",
        "deploy_status": "",
        "run_id": run_id,
        "current_phase": "initial",
        "langstack_log": []
    }
    
    # å®Ÿè¡Œè¨­å®š
    config = {
        "configurable": {
            "thread_id": run_id,
            "simulate": simulate
        }
    }
    
    # å®Ÿè¡Œ
    if simulate:
        print(f"[SIMULATE] Running workflow for: {user_prompt}")
    
    final_state = app.invoke(initial_state, config)
    
    # langstack.txt å‡ºåŠ›
    langstack_path = Path(f"runs/{run_id}/langstack.txt")
    langstack_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(langstack_path, "w") as f:
        f.write("=== LangGraph Execution Log ===\n")
        for log in final_state["langstack_log"]:
            f.write(f"{log}\n")
        f.write(f"\nFinal Phase: {final_state['current_phase']}\n")
        f.write(f"Validation: {final_state['validation_result']}\n")
    
    return final_state


# ==========================================
# CLIçµ±åˆï¼ˆæ—¢å­˜ bin/langstack ã¨ã®äº’æ›æ€§ï¼‰
# ==========================================
if __name__ == "__main__":
    import sys
    from datetime import datetime
    
    if len(sys.argv) < 2:
        print("Usage: python langgraph_runner.py '<user_prompt>' [--simulate]")
        sys.exit(1)
    
    user_prompt = sys.argv[1]
    simulate = "--simulate" in sys.argv
    
    run_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    result = run_mvp_generation(
        user_prompt=user_prompt,
        run_id=run_id,
        strategy="ranked",
        simulate=simulate
    )
    
    print("\n=== Execution Complete ===")
    print(f"Run ID: {run_id}")
    print(f"Phase: {result['current_phase']}")
    print(f"Validation: {result['validation_result']}")
    print(f"SPEC: runs/{run_id}/SPEC.md")
    print(f"Log: runs/{run_id}/langstack.txt")


LangGraphçµ±åˆå®Ÿè£…
registry/manifest_langstack.yaml ã®å®šç¾©ã‚’LangGraphãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«å¤‰æ›
"""

from typing import TypedDict, Literal, Annotated
import operator
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.sqlite import SqliteSaver
from crewağŸ“Š å®Ÿè£…æ¯”è¼ƒ: ç¾è¡Œ vs LangGraphåŒ–
è¦ç´ ç¾è¡ŒPoCLangGraphçµ±åˆçŠ¶æ…‹ç®¡ç†è¾æ›¸ã‚’æ‰‹å‹•ã§å¼•ãå›ã—StateGraph ãŒè‡ªå‹•ç®¡ç†åˆ†å²åˆ¶å¾¡if-else ã§æ‰‹å‹•å®Ÿè£…add_conditional_edges ã§å®£è¨€çš„æ°¸ç¶šåŒ–ãƒ•ã‚¡ã‚¤ãƒ«I/Oã®ã¿SqliteSaver ã§è‡ªå‹•ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆå†å®Ÿè¡Œå…¨ä½“ã‚’æœ€åˆã‹ã‚‰ç‰¹å®šãƒãƒ¼ãƒ‰ã‹ã‚‰å†é–‹å¯èƒ½ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰æ‰‹å‹•ãƒ«ãƒ¼ãƒ—ã‚°ãƒ©ãƒ•ã®ã‚¨ãƒƒã‚¸ã§è‡ªç„¶ã«è¡¨ç¾ãƒ­ã‚°æ‰‹å‹•ã§ langstack.txt æ›¸ãè¾¼ã¿state["langstack_log"] ã«è¿½è¨˜CrewAIçµ±åˆbin/agent_cli çµŒç”±execution_orchestrator_node å†…ã§ç›´æ¥å‘¼ã³å‡ºã—

ğŸ¯ æœ€çµ‚å›ç­”: ã‚ãªãŸã®ã‚±ãƒ¼ã‚¹ã§ã®æœ€é©æ§‹æˆ
âœ… LangGraphä¸»å° + CrewAIãƒãƒ¼ãƒ‰çµ±åˆã‚’æ¨å¥¨
ç†ç”±ï¼ˆãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãƒ™ãƒ¼ã‚¹ï¼‰:

æ—¢ã«è¨­è¨ˆãŒLangGraphãã®ã‚‚ã®

yaml   # manifest_langstack.yaml
   nodes:
     - supreme_orchestrator
     - intent_orchestrator
     - execution_orchestrator
     - validation_orchestrator
ã“ã‚Œã¯å®Œå…¨ã«LangGraphã®StateGraphæ§‹é€ ã€‚

è¤‡é›‘ãªæ¡ä»¶åˆ†å²ãŒå¿…é ˆ

Intentæ¤œå‡ºå¾Œ: missing_info â†’ clarify or yaml_autogen
Validationå¾Œ: approved â†’ review or changes_requested â†’ executionï¼ˆå·®æˆ»ã—ï¼‰
Reviewå¾Œ: approved â†’ deploy or rejected â†’ END


é•·æ™‚é–“å®Ÿè¡Œã¨ä¸­æ–­ãƒ»å†é–‹

timeout_s: 60 ï¼ˆIntent YAMLï¼‰
MVPç”Ÿæˆã¯æ•°åˆ†ã€œæ•°ååˆ†
Checkpointingã§é€”ä¸­ä¿å­˜ãŒå¿…é ˆ


ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰å†å®Ÿè¡Œ

å¤±æ•—æ™‚ã« selected_agents[1], [2], ... ã¨é †æ¬¡å®Ÿè¡Œ
LangGraphãªã‚‰ execution â†’ validation â†’ execution ã®ãƒ«ãƒ¼ãƒ—ã§è‡ªç„¶ã«å®Ÿè£…


CrewAIã¯ execution_orchestrator å†…ã§ã‚«ãƒ—ã‚»ãƒ«åŒ–

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œéƒ¨åˆ†ã ã‘CrewAIã® Crew.kickoff()
å…¨ä½“ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã¯LangGraph




ğŸ—ï¸ æ®µéšçš„ç§»è¡Œãƒ—ãƒ©ãƒ³
Phase 2.1: LangGraphæœ€å°å°å…¥
python# src/agi_poc/langgraph_runner.pyï¼ˆæ–°è¦ï¼‰
from langgraph.graph import StateGraph

workflow = StateGraph(MVPSystemState)
workflow.add_node("intent", intent_orchestrator_node)
workflow.add_node("execution", execution_orchestrator_node)
workflow.add_edge("intent", "execution")

app = workflow.compile()
æ—¢å­˜ã® langstack_runner.py ã¯ãã®ã¾ã¾æ®‹ã—ã€--experimental-langgraph ãƒ•ãƒ©ã‚°ã§åˆ‡ã‚Šæ›¿ãˆã€‚
Phase 2.2: Checkpointingå°å…¥ï¼ˆ1é€±é–“ï¼‰
pythonfrom langgraph.checkpoint.sqlite import SqliteSaver

checkpointer = SqliteSaver.from_conn_string(
    f"runs/{run_id}/checkpoint.db"
)
app = workflow.compile(checkpointer=checkpointer)

# ä¸­æ–­å¾Œã®å†é–‹
app.invoke(None, config={"configurable": {"thread_id": run_id}})
Phase 2.3: CrewAIçµ±åˆ
pythondef execution_orchestrator_node(state):
    # æ—¢å­˜ã® bin/agent_cli å‘¼ã³å‡ºã—ã‚’ç½®ãæ›ãˆ
    crew = Crew(agents=[...], tasks=[...])
    result = crew.kickoff(inputs=state)
    return state
Phase 2.4: æ¡ä»¶åˆ†å²å®Œå…¨åŒ–
pythonworkflow.add_conditional_edges(
    "validation",
    route_after_validation,
    {"review": "review", "execution": "execution"}
)

ğŸš€ å³åº§ã«ä½¿ãˆã‚‹ã‚³ãƒãƒ³ãƒ‰ï¼ˆç§»è¡Œå¾Œï¼‰
bash# LangGraphç‰ˆå®Ÿè¡Œ
python src/agi_poc/langgraph_runner.py "ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚¢ãƒ—ãƒªã®SPECä½œæˆ" --simulate

# å®Ÿé‹ç”¨
python src/agi_poc/langgraph_runner.py "ECã‚µã‚¤ãƒˆã®ä»•æ§˜æ›¸" --yes

# æ—¢å­˜CLIï¼ˆäº’æ›æ€§ç¶­æŒï¼‰
python bin/langstack run --input "è¦ä»¶" --experimental-langgraph

ğŸ“‹ ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
LangGraphå°å…¥å‰ã«ç¢ºèª:

 langgraph, langgraph-checkpoint-sqlite ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
 MVPSystemState ã®å‹å®šç¾©ã‚’ src/agi_poc/schemas.py ã«è¿½åŠ 
 æ—¢å­˜ã® langstack_runner.py ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
 ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æº–å‚™ï¼ˆtests/test_langgraph_integration.pyï¼‰


ğŸ’¡ çµè«–
ã‚ãªãŸã¯æ—¢ã«LangGraphä¸»å°ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’è¨­è¨ˆæ¸ˆã¿ã§ã™ã€‚ç¾åœ¨ã¯PoCã§æ‰‹å‹•å®Ÿè£…ã—ã¦ã„ã¾ã™ãŒã€æ¬¡æ®µéšã§LangGraphå®Ÿè£…ã«ç§»è¡Œã™ã¹ãã§ã™ã€‚
CrewAIã¯ execution_orchestrator ãƒãƒ¼ãƒ‰å†…ã§ä½¿ã„ã€å…¨ä½“åˆ¶å¾¡ã¯LangGraphã«ä»»ã›ã‚‹ã®ãŒæœ€é©ã§ã™ã€‚